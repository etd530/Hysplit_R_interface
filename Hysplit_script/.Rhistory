grays[12] <- "#000000"
#if you change the number of colors in the previous line you must change breaks and legend accordingly
image(spGridDf, col = grays, breaks = (c(0, 0.01, 0.02, 0.03,
0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.99, 1)), add = plot.add)
legend("topleft", legend = c("0.00 - 0.01", "0.01 - 0.02", "0.02 - 0.03",
"0.03 - 0.04", "0.04 - 0.05", "0.05 - 0.06", "0.06 - 0.07",
"0.07 - 0.08", "0.08 - 0.09", "0.09 - 0.1"), fill = grays)
do.call(title, extra.args)
if (!missing(overlay)) {
plot(overlay, add = T, col = "black", border = "black")
}
par(oldpar)
if (pdf == T) {
dev.off()
}
}
# Creating the list with the days of interest ####
dateList <- as.vector(5) # just creating a vector
for(i in 1:length(yearList)) {
for (j in 1:length(monthList)) {
for (k in 1:length(dayList)) {
dateList[length(dayList)*length(monthList)*(i-1)+length(dayList)*(j-1)+k] <- as.character(paste(yearList[i], monthList[j], dayList[k], sep = "-"))
}
}
} # this loop generates the dates
dateList <- as.Date(dateList) # change from strings to Date objects
dateList <- na.omit(dateList) # remove NAs (i.e. remove impossible dates such as February 31)
# Generate list with the dates of the previous month
prevDates <- seq.Date(if (monthList[1]==01) as.Date(paste(yearList[1]-1, "12", "01", sep="-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[1], monthList[1]-1, "01", sep="-"), "%Y-%m-%d", tz = "CET"), # initial date
if (monthList[1]==01) as.Date(paste(yearList[length(yearList)]-1, "12", "01", sep="-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[length(yearList)], monthList[1]-1, "01", sep="-"), "%Y-%m-%d", tz = "CET"), # final date
by = "year",                                   # interval
length.out = NULL)                             # period length
# Get meteorological files:
# I think with the loop is better because if you put the whole list directly in the "days" argument it seems to go over all the months in the middle
# and download unnecessary files
for(i in 1:length(prevDates)) {
get_met_reanalysis(days = prevDates[i], duration = 12, direction = "forward",
path_met_files = "C:/hysplit/working")
}
# Generate list with dates of next month
postDates <- seq.Date(if (monthList[length(monthList)]==12) as.Date(paste(yearList[1]+1, "01", "01", sep = "-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[1], monthList[length(monthList)]+1, "01", sep = "-"), "%Y-%m-%d", tz = "CET"), # initial date
if (monthList[length(monthList)]==12) as.Date(paste(yearList[length(yearList)]+1, "01","01", sep = "-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[length(yearList)], monthList[length(monthList)]+1,"01", sep = "-"), "%Y-%m-%d", tz = "CET"), # final date
by = "year",                                   # interval
length.out = NULL)                             # period length
# Get the files; as before the loop should save time
for(i in 1:length(postDates)) {
get_met_reanalysis(days = postDates[i], duration = 12, direction = "forward",
path_met_files = "C:/hysplit/working")
}
# Get the files for the dates of interest; since the files are by month it does not matter here if the list has more days than needed, it will skip files already downloaded
for(i in 1:length(dateList)) {
get_met_reanalysis(days = dateList[i], duration = 48, direction = "backward",
path_met_files = "C:/hysplit/working")
}
# Calculate trajectories ####
library(raster)       # needed for the lines that change the raster values, from maxValue until setValues, and for pointDistnace()
library(geosphere)    # needed for bearing()
library(viridis)      # colorblind-friendly color palettes
pdf("./Winds_raster.pdf")
pdf("./Winds_raster.pdf")
#png(here("Winds_raster.png"), height=1000, width=700, res=600)
#par(mfcol=c(2,2))
for (n in coord){
for (i in monthList){
for (j in dayblocks){
if (exists("merged_trajs")){rm(merged_trajs)}
for(h in height){
###Calculate the trajectories
# Trajectories for the first day; start at specified hour and end at 23:00
trajFirst <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = times[[1]][1], end.hour = "23:00",
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) == min(j)], tz = "CET")
# Trajectories for the center days; all run from 00:00 to 23:00
traj <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = "00:00", end.hour = "23:00",
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) %in% j & day(dateList) != min(j) & day(dateList) != max(j)], tz = "CET")
# Trajectories for the last day; start at 00:00 and end at specified hour
trajLast <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = "00:00", end.hour = times[[1]][2],
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) == max(j)], tz = "CET")
traj <- rbind(trajFirst, traj, trajLast)
# Plot calculated trajectories in a map
traj_lines<-Df2SpLines(traj, crs = "+proj=longlat +datum=NAD27") #here I just took the crs value from the documentation example as I am not familiar with datums and all that, it may need to be changed
traj_lines_df<-Df2SpLinesDf(traj_lines, traj, add.distance = T, add.azimuth = T) #this line is not really needed but it may be useful for other things
# pdf(here("Winds_map.pdf"))
# PlotTraj(traj_lines_df) #plots the trajectories in a map
# dev.off()
#generates a raster, where each cell has the number of trajectories that pass through it
traj_freq<- RasterizeTraj(traj_lines, parallel = F) #switch to parallel=T to calculate in parallel, but with very few trajectories (less than 8 I think)
#it won't work
# these lines change the absolute number of trajectories to relative number (i.e. from 0 to 1)
max.val <- maxValue(traj_freq)        #gets the max value of the raster
v <- getValues(traj_freq)             #gets all values of the raster
v <- v/max.val                        #divides the values
traj_freq <- setValues(traj_freq, v)  #passes the new values to the raster
max.val<-maxValue(traj_freq)          #get the (new) max value
breaks<-seq(0, max.val, max.val/10)   #this will set the scale of the plot
#plot the rasterized trajectories <- FIX THE SPACES IN THE MAIN TITLE CHANGING SEPARATOR TO NONE AND ADDING THE NECESSARY SPACES
traj_grid<-as(traj_freq, "SpatialGridDataFrame")  #creates object of the necessary type for the package
plotRaster(traj_grid, main = paste0(month.name[i]," ", j[1], " ", times[[1]][1], " to ",
month.name[i], " ", j[length(j)], " ", times[[1]][2], " ",
yearList[1], "-", yearList[length(yearList)], " (", h, "m AGL)")) #plots the raster
#add the starting height of the trajectories as a variable
traj$start_height <- h
#join all trajectories of the same days and different starting heights in a single df
if (exists("merged_trajs")) {
merged_trajs <- rbind(merged_trajs, traj)
} else {
merged_trajs <- traj
}
}
# Calculate distance from origin and angle relative to origin for each trajectory position
merged_trajs$dist <- pointDistance(cbind(merged_trajs$lon, merged_trajs$lat), c(coord[[1]][2], coord[[1]][1]), lonlat = T)
merged_trajs$angle <- bearing(c(coord[[1]][2], coord[[1]][1]), cbind(merged_trajs$lon, merged_trajs$lat))
#we take out values for the starting points, as they are still at the origin so distance is zero and it makes no sense to calculate an angle
merged_trajs$dist[merged_trajs$hour.inc==0] <- NA
merged_trajs$angle[merged_trajs$hour.inc==0] <- NA
#add 360 to negative azimuths
for (i in 1:length(merged_trajs$angle)) {
if (!is.na(merged_trajs$angle[i]) & (merged_trajs$angle[i] < 0)) {
merged_trajs$angle[i] <- merged_trajs$angle[i] + 360
}
}
# turn starting height into factor
merged_trajs$start_height <- as.factor(merged_trajs$start_height)
# Build windrose-type plot
windrose = ggplot(data=merged_trajs, aes(x=angle, fill=start_height)) + geom_histogram() +
coord_polar(start = 0, clip = "off") +
ggtitle(paste0("Wind directions ", month.name[i]," ", j[1], " ", times[[1]][1], " to ",
month.name[i], " ", j[length(j)], " ", times[[1]][2], " ",
yearList[1], "-", yearList[length(yearList)], " (", h, "m AGL)")) +
scale_fill_viridis(discrete = T) +
scale_x_continuous(breaks =c(0, 90, 180, 270) , limits = c(0, 360), labels = c("N", "E", "S", "W")) +
theme(plot.title = element_text(hjust = 0.5))
print(windrose)
}
}
}
warnings()
dev.off()
View(merged_trajs)
View(traj)
traj[traj$hour.inc==0,]
dayList <- c(22:25)                          # put the days of the month here, without caring about short months
monthList <- c(10)                      # months go here
yearList <- c(2013)                    # years
dayblocks <- list(c(22:25))       # Set the blocks of days you want to run together to plot in the same map
coord <- list(c(5.745974, -53.934047))       # coordinates
height <- c(500, 1000, 2000)                               # height of the winds at starting point
duration <- -200                             # how long fowrwards or backwards should the run go
times <- list(c("06:00", "06:00"))          # first and last hour on which the trajectories should start (put the same to run just at one hour)
hourInt <- 1                                # at which intervals should you start new trajectories (every 2 hours, etc.)
#modified version of PlotTrajFreq, so that we can change the scale of the plot and the color scale (I did not find a way to do it directly, it seemed to be hardcoded)
plotRaster=function (spGridDf, background = T, overlay = NA, overlay.color = "white",
pdf = F, file.name = "output", ...)
{
if (pdf == T) {
pdf(file.name, paper = "USr", height = 0, width = 0)
}
oldpar <- par(no.readonly = TRUE)
par(mar = c(0, 0, 0, 0) + 2)
plot.add <- F
extra.args <- list(...)
if (!"main" %in% names(extra.args)) {
extra.args$main <- NULL
}
if (background == T) {
bb <- bbox(spGridDf)
PlotBgMap(spGridDf, xlim = bb[1, ], ylim = bb[2, ],
axes = TRUE)
grid(col = "white")
plot.add <- T
}
grays <- colorRampPalette(c("yellow", "orange", "orangered", "red"))(10) #names are color range, number is how many colors to generate
grays[11] <- "#FFFFFF00"
grays[12] <- "#000000"
#if you change the number of colors in the previous line you must change breaks and legend accordingly
image(spGridDf, col = grays, breaks = (c(0, 0.01, 0.02, 0.03,
0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.99, 1)), add = plot.add)
legend("topleft", legend = c("0.00 - 0.01", "0.01 - 0.02", "0.02 - 0.03",
"0.03 - 0.04", "0.04 - 0.05", "0.05 - 0.06", "0.06 - 0.07",
"0.07 - 0.08", "0.08 - 0.09", "0.09 - 0.1"), fill = grays)
do.call(title, extra.args)
if (!missing(overlay)) {
plot(overlay, add = T, col = "black", border = "black")
}
par(oldpar)
if (pdf == T) {
dev.off()
}
}
# Creating the list with the days of interest ####
dateList <- as.vector(5) # just creating a vector
for(i in 1:length(yearList)) {
for (j in 1:length(monthList)) {
for (k in 1:length(dayList)) {
dateList[length(dayList)*length(monthList)*(i-1)+length(dayList)*(j-1)+k] <- as.character(paste(yearList[i], monthList[j], dayList[k], sep = "-"))
}
}
} # this loop generates the dates
dateList <- as.Date(dateList) # change from strings to Date objects
dateList <- na.omit(dateList) # remove NAs (i.e. remove impossible dates such as February 31)
# Getting the meteorological files ####
# It seems ProcTraj() requires one meteorological file before and after the limits of what you want to plot for some reason,
# so we download the files for the months previous and next to the ones of interest
# Generate list with the dates of the previous month
prevDates <- seq.Date(if (monthList[1]==01) as.Date(paste(yearList[1]-1, "12", "01", sep="-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[1], monthList[1]-1, "01", sep="-"), "%Y-%m-%d", tz = "CET"), # initial date
if (monthList[1]==01) as.Date(paste(yearList[length(yearList)]-1, "12", "01", sep="-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[length(yearList)], monthList[1]-1, "01", sep="-"), "%Y-%m-%d", tz = "CET"), # final date
by = "year",                                   # interval
length.out = NULL)                             # period length
# Get meteorological files:
# I think with the loop is better because if you put the whole list directly in the "days" argument it seems to go over all the months in the middle
# and download unnecessary files
for(i in 1:length(prevDates)) {
get_met_reanalysis(days = prevDates[i], duration = 12, direction = "forward",
path_met_files = "C:/hysplit/working")
}
# Generate list with dates of next month
postDates <- seq.Date(if (monthList[length(monthList)]==12) as.Date(paste(yearList[1]+1, "01", "01", sep = "-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[1], monthList[length(monthList)]+1, "01", sep = "-"), "%Y-%m-%d", tz = "CET"), # initial date
if (monthList[length(monthList)]==12) as.Date(paste(yearList[length(yearList)]+1, "01","01", sep = "-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[length(yearList)], monthList[length(monthList)]+1,"01", sep = "-"), "%Y-%m-%d", tz = "CET"), # final date
by = "year",                                   # interval
length.out = NULL)                             # period length
# Get the files; as before the loop should save time
for(i in 1:length(postDates)) {
get_met_reanalysis(days = postDates[i], duration = 12, direction = "forward",
path_met_files = "C:/hysplit/working")
}
# Get the files for the dates of interest; since the files are by month it does not matter here if the list has more days than needed, it will skip files already downloaded
for(i in 1:length(dateList)) {
get_met_reanalysis(days = dateList[i], duration = 48, direction = "backward",
path_met_files = "C:/hysplit/working")
}
# Calculate trajectories ####
library(raster)       # needed for the lines that change the raster values, from maxValue until setValues, and for pointDistnace()
library(geosphere)    # needed for bearing()
library(viridis)      # colorblind-friendly color palettes
#library(here)
pdf("./Winds_raster.pdf")
#png(here("Winds_raster.png"), height=1000, width=700, res=600)
#par(mfcol=c(2,2))
for (n in coord){
for (i in monthList){
for (j in dayblocks){
if (exists("merged_trajs")){rm(merged_trajs)}
for(h in height){
###Calculate the trajectories
# Trajectories for the first day; start at specified hour and end at 23:00
trajFirst <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = times[[1]][1], end.hour = "23:00",
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) == min(j)], tz = "CET")
# Trajectories for the center days; all run from 00:00 to 23:00
traj <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = "00:00", end.hour = "23:00",
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) %in% j & day(dateList) != min(j) & day(dateList) != max(j)], tz = "CET")
# Trajectories for the last day; start at 00:00 and end at specified hour
trajLast <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = "00:00", end.hour = times[[1]][2],
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) == max(j)], tz = "CET")
traj <- rbind(trajFirst, traj, trajLast)
# Plot calculated trajectories in a map
traj_lines<-Df2SpLines(traj, crs = "+proj=longlat +datum=NAD27") #here I just took the crs value from the documentation example as I am not familiar with datums and all that, it may need to be changed
traj_lines_df<-Df2SpLinesDf(traj_lines, traj, add.distance = T, add.azimuth = T) #this line is not really needed but it may be useful for other things
# pdf(here("Winds_map.pdf"))
# PlotTraj(traj_lines_df) #plots the trajectories in a map
# dev.off()
#generates a raster, where each cell has the number of trajectories that pass through it
traj_freq<- RasterizeTraj(traj_lines, parallel = F) #switch to parallel=T to calculate in parallel, but with very few trajectories (less than 8 I think)
#it won't work
# these lines change the absolute number of trajectories to relative number (i.e. from 0 to 1)
max.val <- maxValue(traj_freq)        #gets the max value of the raster
v <- getValues(traj_freq)             #gets all values of the raster
v <- v/max.val                        #divides the values
traj_freq <- setValues(traj_freq, v)  #passes the new values to the raster
max.val<-maxValue(traj_freq)          #get the (new) max value
breaks<-seq(0, max.val, max.val/10)   #this will set the scale of the plot
#plot the rasterized trajectories <- FIX THE SPACES IN THE MAIN TITLE CHANGING SEPARATOR TO NONE AND ADDING THE NECESSARY SPACES
traj_grid<-as(traj_freq, "SpatialGridDataFrame")  #creates object of the necessary type for the package
plotRaster(traj_grid, main = paste0(month.name[i]," ", j[1], " ", times[[1]][1], " to ",
month.name[i], " ", j[length(j)], " ", times[[1]][2], " ",
yearList[1], "-", yearList[length(yearList)], " (", h, "m AGL)")) #plots the raster
#add the starting height of the trajectories as a variable
traj$start_height <- h
#join all trajectories of the same days and different starting heights in a single df
if (exists("merged_trajs")) {
merged_trajs <- rbind(merged_trajs, traj)
} else {
merged_trajs <- traj
}
}
# Calculate distance from origin and angle relative to origin for each trajectory position
merged_trajs$dist <- pointDistance(cbind(merged_trajs$lon, merged_trajs$lat), c(coord[[1]][2], coord[[1]][1]), lonlat = T)
merged_trajs$angle <- bearing(c(coord[[1]][2], coord[[1]][1]), cbind(merged_trajs$lon, merged_trajs$lat))
#we take out values for the starting points, as they are still at the origin so distance is zero and it makes no sense to calculate an angle
merged_trajs$dist[merged_trajs$hour.inc==0] <- NA
merged_trajs$angle[merged_trajs$hour.inc==0] <- NA
#add 360 to negative azimuths
for (ang in 1:length(merged_trajs$angle)) {
if (!is.na(merged_trajs$angle[ang]) & (merged_trajs$angle[ang] < 0)) {
merged_trajs$angle[ang] <- merged_trajs$angle[ang] + 360
}
}
# turn starting height into factor
merged_trajs$start_height <- as.factor(merged_trajs$start_height)
# Build windrose-type plot
windrose = ggplot(data=merged_trajs, aes(x=angle, fill=start_height)) + geom_histogram(stat = ncount) +
coord_polar(start = 0, clip = "off") +
ggtitle(paste0("Wind directions ", month.name[i]," ", j[1], " ", times[[1]][1], " to ",
month.name[i], " ", j[length(j)], " ", times[[1]][2], " ",
yearList[1], "-", yearList[length(yearList)], " (", h, "m AGL)")) +
scale_fill_viridis(discrete = T) +
scale_x_continuous(breaks =c(0, 90, 180, 270) , limits = c(0, 360), labels = c("N", "E", "S", "W")) +
theme(plot.title = element_text(hjust = 0.5))
print(windrose)
}
}
}
dev.off()
dayList <- c(22:25)                          # put the days of the month here, without caring about short months
monthList <- c(10)                      # months go here
yearList <- c(2013)                    # years
dayblocks <- list(c(22:25))       # Set the blocks of days you want to run together to plot in the same map
coord <- list(c(5.745974, -53.934047))       # coordinates
height <- c(500, 1000, 2000)                               # height of the winds at starting point
duration <- -200                             # how long fowrwards or backwards should the run go
times <- list(c("06:00", "06:00"))          # first and last hour on which the trajectories should start (put the same to run just at one hour)
hourInt <- 1                                # at which intervals should you start new trajectories (every 2 hours, etc.)
#modified version of PlotTrajFreq, so that we can change the scale of the plot and the color scale (I did not find a way to do it directly, it seemed to be hardcoded)
plotRaster=function (spGridDf, background = T, overlay = NA, overlay.color = "white",
pdf = F, file.name = "output", ...)
{
if (pdf == T) {
pdf(file.name, paper = "USr", height = 0, width = 0)
}
oldpar <- par(no.readonly = TRUE)
par(mar = c(0, 0, 0, 0) + 2)
plot.add <- F
extra.args <- list(...)
if (!"main" %in% names(extra.args)) {
extra.args$main <- NULL
}
if (background == T) {
bb <- bbox(spGridDf)
PlotBgMap(spGridDf, xlim = bb[1, ], ylim = bb[2, ],
axes = TRUE)
grid(col = "white")
plot.add <- T
}
grays <- colorRampPalette(c("yellow", "orange", "orangered", "red"))(10) #names are color range, number is how many colors to generate
grays[11] <- "#FFFFFF00"
grays[12] <- "#000000"
#if you change the number of colors in the previous line you must change breaks and legend accordingly
image(spGridDf, col = grays, breaks = (c(0, 0.01, 0.02, 0.03,
0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.99, 1)), add = plot.add)
legend("topleft", legend = c("0.00 - 0.01", "0.01 - 0.02", "0.02 - 0.03",
"0.03 - 0.04", "0.04 - 0.05", "0.05 - 0.06", "0.06 - 0.07",
"0.07 - 0.08", "0.08 - 0.09", "0.09 - 0.1"), fill = grays)
do.call(title, extra.args)
if (!missing(overlay)) {
plot(overlay, add = T, col = "black", border = "black")
}
par(oldpar)
if (pdf == T) {
dev.off()
}
}
# Creating the list with the days of interest ####
dateList <- as.vector(5) # just creating a vector
for(i in 1:length(yearList)) {
for (j in 1:length(monthList)) {
for (k in 1:length(dayList)) {
dateList[length(dayList)*length(monthList)*(i-1)+length(dayList)*(j-1)+k] <- as.character(paste(yearList[i], monthList[j], dayList[k], sep = "-"))
}
}
} # this loop generates the dates
dateList <- as.Date(dateList) # change from strings to Date objects
dateList <- na.omit(dateList) # remove NAs (i.e. remove impossible dates such as February 31)
# Getting the meteorological files ####
# It seems ProcTraj() requires one meteorological file before and after the limits of what you want to plot for some reason,
# so we download the files for the months previous and next to the ones of interest
# Generate list with the dates of the previous month
prevDates <- seq.Date(if (monthList[1]==01) as.Date(paste(yearList[1]-1, "12", "01", sep="-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[1], monthList[1]-1, "01", sep="-"), "%Y-%m-%d", tz = "CET"), # initial date
if (monthList[1]==01) as.Date(paste(yearList[length(yearList)]-1, "12", "01", sep="-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[length(yearList)], monthList[1]-1, "01", sep="-"), "%Y-%m-%d", tz = "CET"), # final date
by = "year",                                   # interval
length.out = NULL)                             # period length
# Get meteorological files:
# I think with the loop is better because if you put the whole list directly in the "days" argument it seems to go over all the months in the middle
# and download unnecessary files
for(i in 1:length(prevDates)) {
get_met_reanalysis(days = prevDates[i], duration = 12, direction = "forward",
path_met_files = "C:/hysplit/working")
}
# Generate list with dates of next month
postDates <- seq.Date(if (monthList[length(monthList)]==12) as.Date(paste(yearList[1]+1, "01", "01", sep = "-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[1], monthList[length(monthList)]+1, "01", sep = "-"), "%Y-%m-%d", tz = "CET"), # initial date
if (monthList[length(monthList)]==12) as.Date(paste(yearList[length(yearList)]+1, "01","01", sep = "-"), "%Y-%m-%d", tz = "CET")
else as.Date(paste(yearList[length(yearList)], monthList[length(monthList)]+1,"01", sep = "-"), "%Y-%m-%d", tz = "CET"), # final date
by = "year",                                   # interval
length.out = NULL)                             # period length
# Get the files; as before the loop should save time
for(i in 1:length(postDates)) {
get_met_reanalysis(days = postDates[i], duration = 12, direction = "forward",
path_met_files = "C:/hysplit/working")
}
# Get the files for the dates of interest; since the files are by month it does not matter here if the list has more days than needed, it will skip files already downloaded
for(i in 1:length(dateList)) {
get_met_reanalysis(days = dateList[i], duration = 48, direction = "backward",
path_met_files = "C:/hysplit/working")
}
# Calculate trajectories ####
library(raster)       # needed for the lines that change the raster values, from maxValue until setValues, and for pointDistnace()
library(geosphere)    # needed for bearing()
library(viridis)      # colorblind-friendly color palettes
#library(here)
pdf("./Winds_raster.pdf")
#png(here("Winds_raster.png"), height=1000, width=700, res=600)
#par(mfcol=c(2,2))
for (n in coord){
for (i in monthList){
for (j in dayblocks){
if (exists("merged_trajs")){rm(merged_trajs)}
for(h in height){
###Calculate the trajectories
# Trajectories for the first day; start at specified hour and end at 23:00
trajFirst <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = times[[1]][1], end.hour = "23:00",
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) == min(j)], tz = "CET")
# Trajectories for the center days; all run from 00:00 to 23:00
traj <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = "00:00", end.hour = "23:00",
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) %in% j & day(dateList) != min(j) & day(dateList) != max(j)], tz = "CET")
# Trajectories for the last day; start at 00:00 and end at specified hour
trajLast <- ProcTraj(lat = n[1], lon = n[2],
hour.interval = hourInt, name = "traj", start.hour = "00:00", end.hour = times[[1]][2],
met = "C:/hysplit/working/", out = "C:/hysplit/working/Out_files/", hours = duration, height = h,
hy.path = "C:/hysplit/", dates = dateList[month(dateList)==i & day(dateList) == max(j)], tz = "CET")
traj <- rbind(trajFirst, traj, trajLast)
# Plot calculated trajectories in a map
traj_lines<-Df2SpLines(traj, crs = "+proj=longlat +datum=NAD27") #here I just took the crs value from the documentation example as I am not familiar with datums and all that, it may need to be changed
traj_lines_df<-Df2SpLinesDf(traj_lines, traj, add.distance = T, add.azimuth = T) #this line is not really needed but it may be useful for other things
# pdf(here("Winds_map.pdf"))
# PlotTraj(traj_lines_df) #plots the trajectories in a map
# dev.off()
#generates a raster, where each cell has the number of trajectories that pass through it
traj_freq<- RasterizeTraj(traj_lines, parallel = F) #switch to parallel=T to calculate in parallel, but with very few trajectories (less than 8 I think)
#it won't work
# these lines change the absolute number of trajectories to relative number (i.e. from 0 to 1)
max.val <- maxValue(traj_freq)        #gets the max value of the raster
v <- getValues(traj_freq)             #gets all values of the raster
v <- v/max.val                        #divides the values
traj_freq <- setValues(traj_freq, v)  #passes the new values to the raster
max.val<-maxValue(traj_freq)          #get the (new) max value
breaks<-seq(0, max.val, max.val/10)   #this will set the scale of the plot
#plot the rasterized trajectories <- FIX THE SPACES IN THE MAIN TITLE CHANGING SEPARATOR TO NONE AND ADDING THE NECESSARY SPACES
traj_grid<-as(traj_freq, "SpatialGridDataFrame")  #creates object of the necessary type for the package
plotRaster(traj_grid, main = paste0(month.name[i]," ", j[1], " ", times[[1]][1], " to ",
month.name[i], " ", j[length(j)], " ", times[[1]][2], " ",
yearList[1], "-", yearList[length(yearList)], " (", h, "m AGL)")) #plots the raster
#add the starting height of the trajectories as a variable
traj$start_height <- h
#join all trajectories of the same days and different starting heights in a single df
if (exists("merged_trajs")) {
merged_trajs <- rbind(merged_trajs, traj)
} else {
merged_trajs <- traj
}
}
# Calculate distance from origin and angle relative to origin for each trajectory position
merged_trajs$dist <- pointDistance(cbind(merged_trajs$lon, merged_trajs$lat), c(coord[[1]][2], coord[[1]][1]), lonlat = T)
merged_trajs$angle <- bearing(c(coord[[1]][2], coord[[1]][1]), cbind(merged_trajs$lon, merged_trajs$lat))
#we take out values for the starting points, as they are still at the origin so distance is zero and it makes no sense to calculate an angle
merged_trajs$dist[merged_trajs$hour.inc==0] <- NA
merged_trajs$angle[merged_trajs$hour.inc==0] <- NA
#add 360 to negative azimuths
for (ang in 1:length(merged_trajs$angle)) {
if (!is.na(merged_trajs$angle[ang]) & (merged_trajs$angle[ang] < 0)) {
merged_trajs$angle[ang] <- merged_trajs$angle[ang] + 360
}
}
# turn starting height into factor
merged_trajs$start_height <- as.factor(merged_trajs$start_height)
# Build windrose-type plot
windrose = ggplot(data=merged_trajs, aes(x=angle, fill=start_height)) + geom_histogram(stat = 'ncount') +
coord_polar(start = 0, clip = "off") +
ggtitle(paste0("Wind directions ", month.name[i]," ", j[1], " ", times[[1]][1], " to ",
month.name[i], " ", j[length(j)], " ", times[[1]][2], " ",
yearList[1], "-", yearList[length(yearList)], " (", h, "m AGL)")) +
scale_fill_viridis(discrete = T) +
scale_x_continuous(breaks =c(0, 90, 180, 270) , limits = c(0, 360), labels = c("N", "E", "S", "W")) +
theme(plot.title = element_text(hjust = 0.5))
print(windrose)
}
}
}
dev.off()
